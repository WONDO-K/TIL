# 트랜잭션 4대 원칙 - ACID

데이터베이스 트랜잭션의 신뢰성을 보장하는 4가지 핵심 원칙을 **ACID**라고 한다.

---

## 1. 원자성 (Atomicity)

- 트랜잭션 내부 연산들이 모두 완전히 실행되거나, 전혀 실행되지 않음을 보장한다.
- 즉, 트랜잭션은 **전체 성공** 또는 **전체 실패** 중 하나만 수행된다.
- 예시: 계좌 이체 트랜잭션

    ```txt
    1. A계좌에서 100,000원 출금
    2. B계좌에 100,000원 입금
    ```
    - 만약 2번 과정에서 에러가 발생하면, 1번 과정도 반드시 취소(rollback)되어야 한다.
- 실제 구현에서는 Commit과 Rollback 명령어를 사용하며, Undo 로그를 통해 이전 상태로 복구한다.

---

## 2. 일관성 (Consistency)

- 트랜잭션이 성공적으로 완료되면 데이터베이스는 항상 **일관성 있는 상태**를 유지해야 한다.
- 트랜잭션 전과 후의 상태가 정의된 규칙을 만족해야 하며, 데이터베이스에 정의된 제약조건(예: 무결성 제약조건 등)을 위반하면 해당 트랜잭션은 취소되어야 한다.
- 예시: 은행 잔고는 음수가 될 수 없으며, 재고 수량은 음수가 되지 않아야 한다.

---

## 3. 고립성 (Isolation, 격리성)

- 동시에 실행되는 여러 트랜잭션이 서로 **독립적으로** 실행됨을 보장한다.
- 필요하다면 트랜잭션을 순차적으로 실행하는 것과 동일한 효과를 가져야 한다.
- 트랜잭션이 진행 중일 때, **다른 트랜잭션은 중간 상태의 데이터를 볼 수 없다**.
- 예시: 계좌 이체 중 A와 B 계좌의 잔고 총합이 일시적으로 변할 수 있지만, 다른 트랜잭션에서는 항상 일관된 총합(예: 10,000원)만 볼 수 있어야 한다.
- 격리 수준(Isolation Level)에는 READ UNCOMMITTED, READ COMMITTED, REPEATABLE READ, SERIALIZABLE 등이 있으며, 높은 격리 수준은 일관성을 높이지만 성능 저하를 초래하는 트레이드오프가 있다.

### 격리 수준
- READ UNCOMMITTED: 다른 트랜잭션의 변경 내용을 읽을 수 있지만, 커밋되지 않은 데이터도 읽을 수 있어 **더티 리드**가 발생할 수 있다.
- READ COMMITTED: 커밋된 데이터만 읽을 수 있어 더티 리드는 방지되지만, **비 반복 읽기**가 발생할 수 있다.
- REPEATABLE READ: 같은 트랜잭션 내에서 동일한 데이터를 여러 번 읽어도 결과가 변하지 않지만, **팬텀 리드**가 발생할 수 있다.
- SERIALIZABLE: 가장 높은 격리 수준으로, 트랜잭션이 순차적으로 실행되는 것과 동일한 효과를 가져온다. 성능 저하가 크다.

#### 더티리드란?
- 정의: 한 트랜잭션이 커밋되지 않은 다른 트랜잭션의 변경 내용을 읽는 현상.
- 왜 문제? 이후 상대 트랜잭션이 ROLLBACK 하면, 읽었던 값은 실제로 존재하지 않는 값이 되어 일관성이 깨짐.
- 발생 환경: READ UNCOMMITTED에서만 발생 가능. READ COMMITTED 이상에서는 방지됨.
- 예시
    - T1: UPDATE account SET balance = balance - 100 WHERE id = 1; (아직 COMMIT 안 함)
    - T2: SELECT balance FROM account WHERE id = 1; → 변경된 값 읽음
    - T1: ROLLBACK → T2는 존재하지 않는 값을 근거로 처리한 셈

#### 팬텀리드란?
- 정의: 같은 조건으로 동일 쿼리를 반복 실행했을 때, 다른 트랜잭션의 INSERT/DELETE 때문에 행의 개수가 달라지는 현상. (값 변화가 포인트인 “비 반복 읽기(Non‑repeatable Read)”와 달리, 팬텀 리드는 행의 출현/소멸이 핵심.)
- 왜 문제? 범위 질의 기반의 집계·검증 로직이 트랜잭션 중간에 깨질 수 있음.
- 발생 환경: REPEATABLE READ에서도 발생 가능. SERIALIZABLE에서만 방지됨.

- 예시
    - T1: SELECT COUNT(*) FROM orders WHERE status='PENDING'; → 10
    - T2: INSERT INTO orders(status) VALUES('PENDING'); → COMMIT
    - T1: 같은 쿼리 재실행 → 11 (새 팬텀 행 등장)
---
#### 팬텀 행 발생 원인(본질)
REPEATABLE READ 격리 수준에서는 이미 조회한 행에는 공유 잠금이 걸리지만, 조건을 만족하는 '아직 존재하지 않는 행'에 대해서는 잠금이 걸리지 않는다. 

이로 인해 다른 트랜잭션이 해당 조건을 만족하는 새 행을 INSERT하거나 기존 행을 DELETE할 수 있으며, 그 결과 재조회 시 행의 개수가 변한다. 

이를 방지하려면 SERIALIZABLE 수준에서 범위 잠금(range lock) 또는 predicate lock을 사용해야 한다.
---

## 4. 지속성 (Durability)

- **성공적으로 완료된 트랜잭션의 결과는 영구적으로 반영**되어야 합니다.
- 시스템 장애가 발생하더라도, 성공적으로 수행된 트랜잭션의 결과는 데이터베이스에 반드시 남아 있어야 한다.
- 일반적으로 트랜잭션의 결과는 로그에 기록되며, 이 로그를 통해 장애 발생 시 복구가 가능하다.
- 이를 위해 WAL(Write-Ahead Logging) 기법을 사용하여 변경 내용을 디스크에 먼저 기록한다.

---

ACID는 전통적인 관계형 데이터베이스에서 신뢰성을 보장하는 반면, NoSQL에서는 BASE 원칙을 통해 확장성과 가용성을 중시한다.