# 스택 (Stack)
스택은 후입선출이라는 개념을 가진 선형 자료구조이다. 스택에서 삭제(POP)은 가장 최상단(TOP)애서만 이루어진다.
비어있는 스택에서 값을 추출하려고 시도하는경우를 스택 언더플로어라고 하며, 스택이 넘치는 경우를 스택 오버플로우라고 한다.
> 대표적인 활용 사례는 스택 메모리, 브라우저 뒤로가기 기능, Undo/Redo, 수식 괄호 검사 등이 있다.

## Java에서 스택
Stack 클래스를 사용할 수 있다. 하지만 Deque 인터페이스 구현체를 사용하는 것을 권장한다.
왜냐하면, Stack 클래스는 Vector 클래스를 상속받아 구현되었기 때문에, Vector를 상속 받은 Stack은 인덱스를 통한 접근, 삽입, 삭제가 가능하다. 이는 후입선출 특징에 어긋나기 때문에, 사용자가 Stack의 후입선출 특징을 무시하고 사용할 수 있다(실수의 가능성). 따라서, Deque 인터페이스를 구현한 LinkedList나 ArrayDeque를 사용하는 것이 좋다.

또한, Vector의 메소드들은 synchronized로 구현되어 있어 멀티 스레드 환경에서는 동기화의 이점이 있으나, 단일 스레드 환경에서는 불필요한 동기화 작업으로 인해 성능 저하가 발생할 수도 있다.
반면에, Deque 인터페이스는 후입선출의 특성을 완전히 유지하면서도 동기화 작업을 가지는 구현체와 그렇지 않은 구현체를 선택할 수 있다. 이는 개발자가 필요에 따라 동기화 작업의 오버헤드를 회피하고 성능을 최적화할 수 있도록 한다.

## 스택의 주요 메소드
- `push(E e)`: 스택의 최상단에 요소를 추가한다.
- `pop()`: 스택의 최상단 요소를 제거하고 반환한다.
- `peek()`: 스택의 최상단 요소를 반환하지만 제거하지는 않는다.
- `isEmpty()`: 스택이 비어있는지 확인한다.
- `size()`: 스택에 있는 요소의 개수를 반환한다.
- `clear()`: 스택의 모든 요소를 제거한다.
## 스택의 시간 복잡도
- `push`: O(1)
- `pop`: O(1)
- `peek`: O(1)
- `isEmpty`: O(1)
- `size`: O(1)              
> 스택의 모든 주요 연산은 상수 시간 복잡도를 가지므로, 스택은 매우 효율적인 자료구조이다.

## Deque 인터페이스를 구현한 LinkedList와 ArrayDeque
- **LinkedList**: 연결 리스트 기반으로 구현되어, 삽입과 삭제가 빠르지만, 인덱스 접근이 느리다. 메모리 사용량이 많을 수 있다.
- **ArrayDeque**: 동적 배열 기반으로 구현되어, 인덱 접근이 빠르며, 메모리 사용량이 상대적으로 적다. 그러나, 크기가 고정되어 있어 크기 조정이 필요할 때는 성능 저하가 발생할 수 있다.
> 일반적으로, 스택을 구현할 때는 ArrayDeque를 사용하는 것이 더 효율적이다. 위의 내용처럼 ArrayDeque는 스택의 후입선출 특성을 잘 지원하며, 메모리 사용량이 적고 인덱스 접근이 빠르다. LinkedList는 삽입과 삭제가 빠르지만, 인덱스 접근이 느리기 때문에 스택의 특성과 잘 맞지 않는다.

## List 계열의 기본 메서드 (ArrayList, LinkedList 등)

- `add(E e)`: 리스트의 끝에 요소를 추가한다.
- `add(int index, E element)`: 지정된 위치에 요소를 삽입한다.
- `remove(Object o)`: 리스트에서 첫 번째로 일치하는 요소를 제거한다.
- `remove(int index)`: 지정된 인덱스의 요소를 제거한다.
- `get(int index)`: 지정된 인덱스의 요소를 반환한다.
- `set(int index, E element)`: 지정된 인덱스의 요소를 지정된 요소로 교체한다.
- `indexOf(Object o)`: 리스트에서 첫 번째로 일치하는 요소의 인덱스를 반환한다.
- `contains(Object o)`: 리스트에 지정된 요소가 포함되어 있는지 확인한다.
- `size()`: 리스트의 요소 개수를 반환한다.
- `isEmpty()`: 리스트가 비어있는지 확인한다.
- `clear()`: 리스트의 모든 요소를 제거한다.

> 참고: `LinkedList`는 `List`와 `Deque` 인터페이스를 모두 구현하므로, 리스트처럼 사용할 수도 있고 큐/스택처럼 사용할 수도 있다. `ArrayList`는 내부적으로 배열 기반이라 인덱스 접근이 빠르지만 중간 삽입/삭제가 느리며, `LinkedList`는 인덱스 접근은 느리지만 삽입/삭제가 빠르다.

## ArrayDeque의 주요 메소드
`ArrayDeque`는 `Deque` 인터페이스를 구현한 클래스이며, 양쪽 끝에서 삽입 및 삭제가 가능. 
아래는 주요 메서드.

### 삽입 메서드
| 메서드 | 동작 | 설명 |
|--------|------|------|
| `addFirst(E e)` | 앞 삽입 | 앞쪽에 요소를 삽입. 공간 부족 시 `IllegalStateException` 발생 |
| `offerFirst(E e)` | 앞 삽입 | 앞쪽에 요소를 삽입. 공간 부족 시 `false` 반환 (예외 없음) |
| `addLast(E e)` | 뒤 삽입 | 뒤쪽에 요소를 삽입. 공간 부족 시 예외 발생 |
| `offerLast(E e)` | 뒤 삽입 | 뒤쪽에 요소를 삽입. 공간 부족 시 `false` 반환 |
| `offer(E e)` | 뒤 삽입 | `offerLast(e)`와 동일. Queue처럼 사용 시 유용 |

### 삭제 메서드
| 메서드 | 동작 | 설명 |
|--------|------|------|
| `removeFirst()` | 앞 제거 | 앞쪽 요소 제거 및 반환. 비어있으면 `NoSuchElementException` |
| `pollFirst()` | 앞 제거 | 앞쪽 요소 제거 및 반환. 비어있으면 `null` 반환 |
| `removeLast()` | 뒤 제거 | 뒤쪽 요소 제거 및 반환. 비어있으면 예외 발생 |
| `pollLast()` | 뒤 제거 | 뒤쪽 요소 제거 및 반환. 비어있으면 `null` 반환 |
| `poll()` | 앞 제거 | `pollFirst()`와 동일. Queue처럼 사용할 때 주로 사용 |

### 조회 메서드
| 메서드 | 동작 | 설명 |
|--------|------|------|
| `getFirst()` | 앞 조회 | 앞쪽 요소 반환. 비어있으면 예외 발생 |
| `peekFirst()` | 앞 조회 | 앞쪽 요소 반환. 비어있으면 `null` 반환 |
| `getLast()` | 뒤 조회 | 뒤쪽 요소 반환. 비어있으면 예외 발생 |
| `peekLast()` | 뒤 조회 | 뒤쪽 요소 반환. 비어있으면 `null` 반환 |
| `peek()` | 앞 조회 | `peekFirst()`와 동일. Queue처럼 사용할 때 사용 |

> `add/remove/get` 계열은 실패 시 예외를 던지고, `offer/poll/peek` 계열은 실패 시 null 또는 false를 반환합니다. 안정적인 코드를 원한다면 `offer/poll/peek`을 사용하는 것이 좋습니다.
