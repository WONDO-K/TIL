# 스레드, 프로세스, 코어의 수는 많으면 좋은가?
스레드, 프로세스, 코어의 수가 많을 수록 시스템 성능이 향상된다고 생각할 수 있지만, 실제로는 그렇지 않을 확률이 크다.

### 요약
| 항목 | 많을 때 장점 | 많을 때 단점 |
|------|--------------|--------------|
| 스레드 | 병렬성 증가 | 컨텍스트 스위칭 비용 증가, 자원 경합, 동기화 복잡성 |
| 프로세스 | 안정성 증가(격리) | 메모리 낭비, IPC 성능 저하, 오버헤드 큼 |
| 코어 | 병렬 처리 성능 향상 | 소프트웨어 최적화 필요, 비용·전력·발열 증가 |

## 스레드가 많으면?
스레드가 지나치게 많아지면 운영체제가 스레드 간 컨텍스트 스위칭(문맥교환)을 자주 수행해야 하여 CPU 자원이 스레드 관리에 소모된다. 이로 인해 실제 작업 수행 효율이 떨어질 수 있으며, 많은 스레드가 동시에 실행될 경우 메모리나 캐시, 락 등의 자원을 경쟁하게 되어 성능 저하나 데드 락이 발생할 가능성이 높아진다. 또한, 스레드가 많아지면 동기화와 상태 관리가 복잡해져 버그 발생 가능성도 커진다.

## 프로세스가 많으면?
각 프로세스는 독립된 메모리 공간을 가진다. 그래서 많은 프로세스가 동시에 실행되면 메모리 사용량이 급격히 증가할 수 있다. 또한, 프로세스를 생성하고 관리하는 데는 상당한 시스템 자원이 소모되며, 프로세스 간 통신(iPC)이 필요할 경우 성능 저하가 발생할 수 있다. 프로세스 간 컨텍스트 스위칭은 스레드 간 컨텍스트 스위칭 보다 더 많은 오버헤드를 수반하기 때문에, 프로세스 수가 많아지면 시스템 성능이 저하될 수 있다.
운영 체제는 동시에 실행할 수 있는 프로세스 수에 제한이 있으며, 이를 초과하면 새로운 프로세스 생성이 불가능하거나 시스템이 불안정해질 수 있다.

## 코어가 많으면?
많은 코어를 가진 CPU는 병렬 처리 성능을 향상시킬 수 있지만, 이를 최대한 활용하기 위해서는 소프트웨어가 멀티코어 환경에 최적화되어 있어야 한다.
단일 스레드 작업이 주를 이루는 경우, 추가 코어의 이점을 제대로 활용하지 못할 수 있다. 또한, 코어 수가 많아질수록 CPU의 비용과 전력 소비가 증가할 수 있으며, 발열 관리도 더 복잡해진다.
-> I/O 지연이 많은 작업(ex. DB대기, 네트워크 호출)
> “코어가 많을수록 성능이 향상될 수는 있지만, 병렬화 가능한 구조인지 여부가 더 중요하다”

### 실무 팁
• 단순히 스레드, 프로세스를 늘리는 것보다, 병렬 처리가 가능한 작업인지 판단하고 적절히 분할해야 한다.
• CPU 코어 수보다 많은 스레드가 항상 성능을 향상시키지 않는다. 오히려 적절한 스레드 수 조정이 중요하다.
• Java에서는 `Executors.newFixedThreadPool(코어 수)` 등으로 코어 수에 맞게 스레드 풀을 설정하는 것이 일반적이다.
• G1 GC 등 일부 GC는 코어 수가 많을수록 병렬 수집에 유리하나, JVM 튜닝이 반드시 필요하다.

### 면접 예상 질문
#### “코어 수를 늘렸더니 성능이 개선되지 않는 이유는 무엇인가요?”
-> SW가 멀티코어 환경에 최적화 되지 않거나 단일 스레드 작업이 주를 이루는 경우, 혹은 I/O의 지연이 많은 DB대기, 네트워크 호출 작업인 경우

#### “CPU는 놀고 있는데 응답 속도가 느린 이유는?”
-> 이는 대부분 I/O 지연 때문일 가능성이 크다. CPU는 계산할 준비가 되어 있어도, 네트워크 응답 대기, 디스크 읽기, DB 쿼리 등 I/O 작업이 완료되기를 기다리는 동안 CPU는 idle 상태가 될 수 있다. 즉, 병목은 CPU가 아닌 외부 자원(I/O)에 있는 경우이다.


#### “스레드 수를 CPU보다 많이 잡는 게 항상 좋은가요?”
-> 아니다. 스레드가 많아질수록 컨텍스트 스위칭 비용이 증가하고, 공유 자원 접근 시 락 경합이 발생할 수 있다. 병렬 처리가 유리한 작업이라면 효과를 볼 수 있지만, 무작정 스레드를 많이 생성하는 것은 오히려 성능을 떨어뜨릴 수 있다.
