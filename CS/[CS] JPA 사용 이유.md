# JPA를 사용하는 이유

데이터 액세스 기술을 사용하는 Spring 기반 애플리케이션을 더 쉽게 구축할 수 있다.

애플리케이션에 대한 데이터 액세스 계층을 구현하는 것은 상당히 번거로울 수 있다. 가장 간단한 쿼리를 실행하려면 너무 많은 상용구 코드를 작성해야 한다. 페이지 매김, Auditing, 기타 자주 필요한 옵션을 추가하면 결국 길을 잃게 된다.

Spring Data JPA는 실제로 필요한 만큼의 노력으로 데이터 액세스 계층의 구현을 크게 개선하는 것을 목표로 한다. 개발자는 다양한 기술을 사용하여 리포지토리 인터페이스를 작성하면 Spring이 자동으로 이를 연결해 준다. 심지어 사용자 정의 파인더를 사용하거나 예제를 통해 쿼리를 작성하면 Spring이 쿼리를 작성해 준다.

- 더 이상 DAO 구현이 필요하지 않다. 인터페이스를 확장함으로써 표준 DAO에서 사용할 수 있는 표준 데이터 액세스에 가장 적합한 CRUD 방법을 얻을 수 있다.
- 사용자 정의 액세스 메서드 및 쿼리
    - 인터페이스에서 새로운 메소드를 정의하기만 하면 됩니다.
    - @Query 주석을 사용하여 JPQL 쿼리 제공
    - Spring Data의 고급 사양 및 Querydsl 지원을 사용
    - JPA Named 쿼리를 통해 사용자 정의 쿼리 사용
- Automatic 사용자 정의 쿼리: 정의된 모든 메서드를 분석하고 메서드 이름에서 쿼리를 자동으로 생성 하려고 시도합니다
- Transaction Configuration: 클래스 수준에서 읽기 전용 @Transactional 주석을 사용하고, 읽기 전용이 아닌 메서드에 대해 재정의됩니다.

---

## ✅ 보안 관련 보완이 필요한 부분

1. **JPQL 및 메서드 이름 기반 쿼리의 안전성**  
   - Spring Data JPA는 메서드 이름 기반으로 쿼리를 생성하지만, 복잡한 쿼리에서는 @Query나 nativeQuery를 사용하게 됩니다.  
   - ⚠️ 주의할 점: Native Query를 직접 사용할 경우 SQL Injection에 취약할 수 있음  
   - ✅ 대응 방법: `@Query`의 파라미터 바인딩은 반드시 `:param` 방식 사용 (예: `@Query("SELECT u FROM User u WHERE u.name = :name")`)

2. **Lazy Loading과 보안**  
   - 연관관계를 지연로딩(LAZY)으로 설정한 엔티티에서, 세션 종료 이후 민감한 정보에 접근하면 LazyInitializationException과 함께 정보 노출 위험 발생 가능  
   - ✅ 대응 방법: DTO 변환 시점 명확하게 구분, Controller 레이어에서 직접 엔티티 반환 금지

3. **엔티티 내부에 민감 정보 포함 금지**  
   - JPA 엔티티에 비밀번호, 주민번호, 인증 토큰 등 민감 정보를 포함시키는 것은 위험함  
   - ✅ 대응 방법: 엔티티와 별도의 DTO 혹은 Value Object로 민감 정보는 분리

4. **Auditing 기능 사용 시 주의**  
   - `@CreatedBy`, `@LastModifiedBy` 같은 필드는 사용자 정보를 저장하지만, 이 정보가 변조되거나 노출되지 않도록 주의  
   - ✅ 대응 방법: Spring Security 연동 시 `AuditorAware` 구현 클래스에서 `SecurityContextHolder` 기반으로 사용자 ID 추출

5. **트랜잭션 내부에서 예외 처리 미흡**  
   - 트랜잭션이 롤백되지 않고 민감 데이터가 잘못 저장되는 경우 발생 가능  
   - ✅ 대응 방법: `@Transactional` 사용 시 try-catch 내부에서 예외를 삼켜버리면 롤백되지 않음 → 반드시 예외 전파 구조 확인