# 동기 방식으로 외부 서비스를 호출할 때 외부 서비스 장애가 나면 어떻게 조치해야 하는가?
- 외부 서비스 장애로 인햏 응답이 오래걸린다고 했을 때 외부 API 응답으로 대기하는 자원들이 운영 서버 내부에 쌓이면서 성능에 악영향을 줄 수 있다.
- 이를 해결하기 위한 가장 기본적인 방법은 타임아웃을 설정하는 것이다.
> 크게 타임아웃에는 커넥션 타임아웃과 리드 타임아웃, HTTP 커넥션 풀 타임아웃을 설정해 볼 수 있다.

## 다음과 같이 특정 서비스의 장애가 전체 서비스에 영향을 주는 경우 어떻게 해결할 수 있을까?
```txt
1. A 서비스, B 서비스, C 서비스 연동 코드가 HTTP 커넥션 풀을 공유한다.
2. A 서비스의 장애로 응답 시간 지연이 발생하는 경우
    2-1. 풀에 남은 커넥션이 점점 줄어든다.
    2-2. 풀에서 커넥션을 구하는 대기 시간이 증가한다.
    2-3. B, C 서비스에 대한 연동도 함께 대기한다.
```
이 경우에는 벌크헤드 패턴을 적용해 볼 수 있다.
벌크헤드 패턴은 기능의 종류마다 자원 사용을 분리하는 것을 의미한다. 
자원을 격리하여 서비스 일부에 장애가 발생해도 정체로 전파되지 않도록 보장해 주는 패턴이다.
위 예시에서는 외부 서비스마다 다른 HTTP 커넥션 풀을 사용하도록 벌케헤드 패턴을 적용할 수 있다.
서로 다른 커넥션 풀을 사용하기 때문에 A 서비스에 문제가 발생해도 B,C의 영향을 최소화할 수 있다.

## 외부 서비스 장애가 계속 발생한다면?
지속되는 외부 서비스 장애로 타임아웃에 의한 서비스 에러가 발생할 수 있다.
외부 서비스가 장애가 발생했는데도 불구하고 운영 서버는 게속 요청을 보내게 되니, 불필요하게 응답시간이 저해되고, 처리량도 감소하게 된다. 이 문제를 해결하기 위해서는 서킷 브레이커를 적용할 수 있다.
서킷 브레이커는 오류가 지속되는 경우 일정 시간 동안 기능 실행을 차단할 수 있다.
서킷 브레이커가 빠른 실패를 도와주기 떄문에 외부 서비스 장애에 의한 응답 시간 증가를 예방할 수 있다.

## 개념 설명

### 타임 아웃
어떤 작업(요청, 연결 등)이 일정 시간 안에 끝나지 않으면 강제로 중단하는 것.
#### 왜 필요한가?
- 외부 서비스가 장애 상태거나, 네트워크가 지연되면 요청이 무한정 대기할 수 있다.
- 대기하는 동안 애플리케이션의 쓰레드나 자원이 점점 고갈되어 전체 시스템 성능에 악영향을 준다.
- 최대로 기다릴 수 있는 시간을 정해서, 초과 시 예외를 발생시키고 빠르게 실패 처리하도록 하는 것.

| 타임아웃 종류 | 설명 |
|--------|------|
|커넥션 타임아웃|서버와의 연결이 맺어지지 않으면 일정 시간 이후에 실행|
|리드 타임아웃|서버 연결은 성공했지만, 응답 데이터가 일정 시간안에 오지 않으면 실패|
|커넥션 풀 타임아웃|연결을 재사용하는 풀에서 유효 커넥션 확보 실패 시 타임아웃 발생|
> 타임아웃을 설정하면 느린 외부 서비스의 영향으로 자원이 묶이는 것을 방지할 수 있다.
> 너무 짧게 잡으면 정상 요청도 실패하고, 너무 길면 효과가 없어진다. -> 적절한 값 설정을 잘하자!



### 벌크헤드 패턴
벌크헤드는 자원을 격리해서 하나의 실패가 전체 시스템에 영향을 주지 않도록 보호하는 패턴.
이름은 배의 방수 격벽(bulkhead)에서 유래 → 한 칸이 물에 잠겨도 배 전체가 가라앉지 않음.

#### 예시
```txt
A, B, C 서비스가 동일한 HTTP 커넥션 풀을 사용하면 -> A가 장애일 때, B,C도 대기
각 서비스별로 분리된 커넥션 풀 사용 -> A 장애 시에도 B,C는 정상 작동
```
#### 적용방법
| 구분 | 내용 |
|--------|------|
|커넥션 풀 분리|서비스별 커넥션 풀 따로 구성(Ex. RestTemplate, WebClient 별도)|
|스레드 풀 분리|비동기 처리 시 스레드 풀을 서비스별로 나누어 장애 전파 방지|

> 벌크헤드는 시스템 일부가 장애가 전체 장애로 확산되는 것을 막기 위해 리소스(커넥션, 스레드) 격리에 중점을 둔다.

---

### 벌크헤드 패턴과 MSA 아키텍처의 관계

벌크헤드(Bulkhead) 패턴은 MSA(Microservices Architecture)와 공통적인 철학을 가지고 있다. 둘 다 장애가 전체 시스템으로 확산되는 것을 방지하고, 독립성과 격리를 통해 시스템의 복원력을 향상시킨다.

#### 공통 철학: 격리와 독립성
| 구분 | 벌크헤드 패턴 | MSA 아키텍처 |
|------|---------------|--------------|
| 적용 위치 | 서비스 내 (애플리케이션 내부 자원 격리) | 서비스 간 (애플리케이션 단위 격리) |
| 보호 대상 | 커넥션, 스레드, 메모리 등 프로세스 자원 | 서비스 전체의 장애 전파 |

벌크헤드는 마이크로서비스 내부에서 커넥션 풀, 스레드 풀 등 자원을 격리하여 일부 기능 장애가 전체 시스템에 영향을 주지 않도록 한다.  
MSA는 서비스 단위로 독립성을 유지하여 한 서비스 장애가 다른 서비스에 영향을 주지 않도록 한다.

#### 적용 예시
| 상황 | 벌크헤드로 해결 | MSA로 해결 |
|------|-----------------|------------|
| 하나의 서비스 내 A/B/C 기능 중 A가 장애 | A의 자원(커넥션 풀, 스레드 풀)만 고립 | 해당 상황은 MSA 적용 대상 아님 |
| 특정 마이크로서비스 장애 | 적용 대상 아님 | 개별 서비스만 격리, 전체 장애 방지 |

결론적으로 벌크헤드 패턴은 MSA 아키텍처의 장애 전파 방지 철학을 더 작은 단위(서비스 내부 자원)로 확장 적용한 것이다.