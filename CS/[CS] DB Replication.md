# DB Replication
데이터베이스의 고가용성과 데이터 안전성을 보장하기 위해 널리 활용되는 핵심 기술이다.
특히, 대규모 애플리케이션 환경에서는 데이터의 지속적인 가용성과 신뢰성이 매우 중요하기 때문에, 원본(Source) 서버와 복제(Replica) 서버간의 데이터 동기화는 필수적이다.

## 바이너리 로그(Binary Log)를 저장하는 방식
Replication은 Source 서버에서 발생하는 모든 데이터 변경사항을 Replica 서버로 복제하여 두 서버 간의 데이터 일관성을 유지하는 메커니즘이다. 이러한 과정은 주로 Binary Log를 기반으로 이루어지며, Binary Log는 Source 서버에서 실행된 모든 데이터 변경 쿼리를 기록하는 역할을 한다. MySQL에서는 이 Binary Log를 저장하는 방식으로
Row, Statement, Mixed 3가지 모드를 제공하며, 각 모드는 데이터 변경 사항을 기록하는 방식이 다르다.

## Row 모드
Row 모드는 데이터베이스의 각 행(row) 단위로 변경 사항을 기록한다. 이 방식은 데이터의 일관성을 매우 높게 유지할 수 있다는 큰 장점이 있다. 예를 들어, 특정 행이 변경되었을 때 그 행의 이전 상태와 변경된 상태를 모두 기록하므로, 복제 서버에서도 원본 서버와 동일한 데이터 상태를 유지할 수 있다. 그러나 모든 행의 변경 사항을 저장하기 때문에 Binary Log 파일의 크기가 급격히 커질 수 있는 단점이 있다. 또한, 복제 과정에서 행 단위로 데이터를 처리하기 때문에 성능 저하가 발생할 수 있다.

## Statement 모드
Statement 모드는 데이터 변경을 일으킨 SQL 쿼리문 자체를 Binary Log에 기록한다. 이 방식은 로그 파일의 크기를 상대적으로 작게 유지할 수 있어 저장 공간을 절약할 수 있다는 장점이 있다. 하지만 실행할 때마다 다른 값을 반환하는 함수와 같이 비확정적(non-deterministic) SQL 쿼리가 실행된 경우, 동일한 쿼리가 Source와 Replica 서버에서 다른 결과를 초래할 수 있어 데이터 일관성에 문제가 발생할 수 있다. 예를 들어, SELECT NOW()와 같은 함수는 실행 시점에 따라 다른 결과를 반환할 수 있기 때문에, 이를 포함한 쿼리는 복제시 문제가 발생할 수 있다.

## Mixed 모드
이러한 문제를 보완하기 위해 MySQL은 Mixed 모드를 제공한다. Mixed 모드는 상황에 따라 Row 기반과 statement 기반을 혼합하여 로그를 기록한다. 비확정적 SQL이 아닌 경우에는 statement 모드를 사용하여 저장공간을 절약하고, 비확정적 SQL이 실행되는 경우에는 Row 모드를 사용하여 데이터의 일관성울 확보한다. 이를 통해 두 방식의 장점을 모두 활용할 수 있으며, 데이터 불일치 문제를 최소화할 수 있다. 다만, 구현이 다소 복잡할 수 있다는 단점이 존재한다.

## 복제 과정
Source 서버에서 데이터 변경 쿼리가 실행되고, 선택된 로그 저장 방식에 따라 Binary Log에 기록된 후, Replica 서버의 Relay Log로 전달된다. Relay Log는 Replica 서버에서 Source 서버의 Binary Log를 저장하는 임시 저장소 역할을 하며, 이곳에서 저장된 로그를 기반으로 Replica 서버의 SQL 스레드가 실제 데이터베이스에 변경사항을 적용한다. 이 과정은 매우 효율적으로 설계되어 일반적으로 약 100ms 이내에 데이터 동기화가 이루어진다. 빠른 속도 덕분에 원본과 복제 서버 간의 데이터 일관성을 거의 실시간으로 유지할 수 있다.

---

## 읽기 요청 분산과 Read Only 설정

대규모 서비스에서는 읽기 요청(SELECT)이 전체 트래픽의 대부분을 차지하며, 이를 하나의 DB 서버가 모두 처리하면 병목이 발생할 수 있다. 이를 해결하기 위해 Replica 서버를 여러 개 구성하고, 이들에 `read_only` 설정을 적용한 후 읽기 요청을 분산시킨다.

### Read Only 설정이란?
Replica 서버는 Primary(Source)에서 복제된 데이터를 가지고 있으며, 보통 쓰기 작업은 하지 않는다. 실수로 데이터를 변경하지 않도록 하기 위해 `read_only` 옵션을 설정해 쓰기 작업을 차단할 수 있다.

```bash
# my.cnf 설정 예시
read_only = 1
super_read_only = 1
```

- `read_only = 1`: 일반 사용자 계정의 쓰기 작업을 금지
- `super_read_only = 1`: root 등 슈퍼 계정까지 포함해 완전히 쓰기 금지

### 요청 분산 구조 예시

```
[Client 요청]
       |
       V
   [Application 서버]
       |
  ┌────┴────┐
  |         |
[Primary] [Replica]
 (쓰기)     (읽기, read_only)
```

애플리케이션은 쓰기 요청은 Primary로, 읽기 요청은 Replica로 전송하여 DB 부하를 분산시킨다. 이 방법은 보고서 생성, 조회 화면 등 조회 트래픽이 많은 환경에서 효과적이다.

단, Replica는 복제 지연(replication lag)이 발생할 수 있으므로, 실시간성이 매우 중요한 데이터는 Primary에서 직접 읽어야 한다.

---

## 애플리케이션에서 읽기/쓰기 요청 분리 방법

Replica를 구성하더라도 애플리케이션이 적절히 요청을 분산시키지 않으면 부하 분산 효과를 얻을 수 없다. 이를 위해 다음과 같은 방법들이 활용된다:

### 1. 애플리케이션 코드에서 분기 처리
- 읽기 쿼리는 Replica로, 쓰기 쿼리는 Primary로 명시적으로 전송
- 예: `@Transactional(readOnly = true)` 여부에 따라 데이터소스를 분기

### 2. 커넥션 풀 분리
- `primaryDataSource`, `replicaDataSource`를 따로 구성
- HikariCP, DBCP 등 커넥션 풀에서 read/write 라우팅 설정

### 3. ORM 또는 DB 라우팅 라이브러리 사용
- Spring Cloud, MyBatis Read/Write Plugin, Vitess 등은 SQL 종류에 따라 라우팅
- 애플리케이션 코드 수정을 최소화 가능

### 4. DB Proxy 사용
- ProxySQL, MySQL Router 등의 미들웨어를 통해 read/write 요청을 자동으로 분산
- 클라이언트는 단일 엔드포인트로 접속

### 5. ORM 설정 기반 분기
- MyBatis는 Mapper ID 또는 SQL 성격에 따라 read/write 분리
- JPA는 트랜잭션 설정 기반 분리

> 실시간성이 필요한 조회는 반드시 Primary를 사용해야 함 (예: 로그인 후 변경 직후의 프로필 조회 등)