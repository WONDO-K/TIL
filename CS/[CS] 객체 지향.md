**1. 절차지향 vs 객체지향**

**✅ 면접 답변 예시**

> 절차지향은 순차적으로 명령을 수행하는 방식으로, 로직 중심의 구조입니다. 반면 객체지향은 데이터를 중심으로, 관련된 함수와 속성을 객체 단위로 묶어서 처리합니다. 객체 간의 상호작용을 통해 프로그램을 구성하는 것이 특징입니다.
> 

**✅ 주요 개념 정리**

| **항목** | **절차지향 (Procedural)** | **객체지향 (OOP)** |
| --- | --- | --- |
| 중심 | 함수(절차) 중심 | 객체 중심 |
| 재사용성 | 낮음 | 높음 (상속, 다형성 등) |
| 유지보수 | 어렵다 | 비교적 쉬움 |
| 예시 언어 | C | Java, Python, C++ |

**✅ 예상 꼬리 질문**

•	OOP의 4가지 핵심 개념은?

> 추상화, 캡슐화, 상속, 다형성
> 

•	절차지향이 더 적합한 경우는?

> 하드웨어 제어, 간단한 프로그램, 성능이 중요한 시스템 등
> 

| 항목 | 절차지향 | 객체지향 |
| --- | --- | --- |
| 중심 개념 | 함수(절차) 중심 | 객체(데이터+기능) 중심 |
| 단위 | 함수(Function) | 객체(Object) |
| 코드 재사용성 | 낮음 | 높음(상속, 다형성 등 활용 가능) |
| 유지보수 | 어렵고 불안정 | 유연하고 용이 |
| 확장성 | 구조가 고정적이라 여려움 | 객체간의 관계를 통해 유연하게 확장 가능 |
| 데이터 은닉 | 전역 변수 사용이 많음 | 캡슐화를 통해 데이터 은닉이 가능 |
| 전체 구조 설계 | 상향식(작은 함수 → 큰 시스템) | 하향식(큰 객체 → 세부 구현) |
| 사용 예시 | 임베디드 시스템, 하드웨어 제어 | 웹 애플리케이션, 게임, GUI 앱 등 |
| 적합 환경 | 성능 최우선 환경 | 유지보수 및 기능 확장이 중요한 환경 |
| 예시 언어 | C, Pascal | Java, Python, C++, Kotlin |

## 예상 질문

**✅ 예상 질문 1:** 절차 지향과 객체 지향의 차이를 설명해보세요

- 절차지향은 순차적으로 작업을 수행하는 방식으로 로직 중심의 구조이고, 객체지향은 데이터를 중심으로 기능을 묶어서 객체 단위로 설계합니다.
- 유지보수성과 코드 재사용성은 객체 지향이 더 우수합니다.

**✅ 꼬리 질문 1: 왜 절차지향 방식이 유지보수가 어려운가요?**

- 절차 지향에서는 모든 데이터가 전역으로 사용되거나 여러 함수에 공유되다 보니, 한 곳에서의 변경이 여러 함수에 영향을 미칩니다. 이로 인해 변경이 전체 흐름에 영향을 주기 때문에 디버깅, 수정 시 어려움이 많습니다.

**✅ 꼬리 질문 2: 그럼 왜 객체지향이 유지보수에 유리합니까?**

- 객체지향은 데이터와 기능을 하나의 객체에 캡슐화하고(하나로 묶는다는 의미), 클래스 간의 상속과 다형성을 통해 기능 확장이 가능하므로, 기존 코드를 건드리지 않고도 새로운 기능을 추가할 수 있습니다.
- 또한 의존성이 줄어들기 떄문에 수정에 용이하다 할 수 있습니다.

**✅ 꼬리 질문 3: 각 방식의 단점을 비교 해보자면?**

- 절차 지향
    - 코드 중복 발생
    - 유지 보수 어려움
    - 규모가 커지면 가독성 하락
- 객체 지향
    - 설계가 복잡함
    - 초반 생산성이 낮음
    - 과한 추상화로 오히려 불편할 수 있음

**✅ 꼬리 질문 4: 그럼 객체지향이 항상 좋은 방식인가?**

- 상황에 따라 다르다
    - 성능이 최우선이 경우(임베디드 or 리소스가 제한된 환경 등)에서는 절차지향이 더 적합할 수 있스니다.
    - 객체 지향은 복잡한 비즈니스 로직이나 대규모 시스템에서 더 효과적입니다.

**✅ 예상 질문 2: 객체지향의 핵심 개념 4가지 설명해보세요**

캡추다정상

- 추상화 : 공통된 속성과 동작을 추출하여 수퍼 클래스로 구성
    - 복잡한 내부 구조는 숨기고, 필요한 기능만 외부에 노출하는 것
- 캡슐화 : 데이터와 메서드를 하나의 단위로 묶고, 외부에서 직접 접근을 제한하는 개념
- 상속 : 기존 클래스의 기능을 재사용하거나 확장할 수 있도록 하는 구조
- 다형성 : 동일한 인터페이스로 다양한 객체의 동작을 실행할 수 있는 능력

개념 설명

- 캡슐화
    - 데이터(속성)와 메서드(행위)를 하나의 객체로 묶고, 외부에서의 직접 접근을 제한
    - 목적 : 정보 은닉 - > 외부 객체가 내부 구조를 알지 못하도록 보호
    - 장점 : 코드 안정성 증가, 변경 용이
    - 주의할 점 : 과도한 getter/setter의 사용은 캡슐화를 무의미하게 만들 수 있다.
- 추상화
    - 복잡한 구현은 숨기고, 필요한 기능만 외부에 공개하는 설계 방식
    - 목적 : 복잡도 감소, 사용자의 이해를 돕는 구조 제공
    
    ```java
    interface Animal { void speak(); }
    - 개발자는 동물이 "운다" 라는 동작만 알고 있으면 된다.
    - 동물이 어떻게 우는지(how)에 (내부 구현) 은 모를 수 있다.
    ```
    
    - 장점 : 유연성 증가, 모듈 간의 결합도 감소
    - 주의할 점 : 과도한 추상화는
- 상속
    - 기존 클래스의 속성과 메서드를 물려받아 새로운 클래스를 정의
    - 목적 : 코드 재사용, 계층 구조 형성
    - 장점 : 중복 제거, 유지보수 용이
    - 단점 : 다중 상속은 복잡도 증가, 잘못된 상속은 결합도 증가
- 다형성
    - 동일한 인터페이스를 구현한 객체가 다양한 방식으로 동작
    - 목적 : 유연한 코드, 인터페이스 기반 설계 가능
    
    ```java
    Animal a = new Dog(); a.speak();
    - 같은 speak()지만 객체에 따라 다른 동작
    ```
    
    - 장점 : 새로운 기능 추가 시 기존 코드 수정 최소화
    

**✅ 꼬리 질문 1: 다형성을 어떻게 실무에 적용해보셨나요?**

회원가입 기능을 구현할 때, 사용자 유형이 ‘부모’와 ‘자녀’로 나뉘는 구조였습니다.
저는 User라는 공통 상위 클래스를 정의하고, 이를 상속받은 Parent와 Child 클래스를 만들었습니다.

서비스 로직에서는 User 타입으로 처리하고, 실제 동작은 런타임 시점에 Parent나 Child 인스턴스에 따라 달라지게 구성했습니다.
예를 들어, 가입 시 부모는 결제 연동 정보를, 자녀는 급식 카드 정보를 입력하도록 분기 처리가 필요했는데, 이를 오버라이딩한 메서드를 통해 깔끔하게 구현할 수 있었습니다.

**✅ 꼬리 질문 2: 상속의 단점은 무엇이고, 대안이 있다면?**

- 상속은 부모 클래스에게 강하게 의존하게 되어 부모의 코드가 변경되면 자식의 코드가 깨지는 경우가 생깁니다.
- 다중 상속 시 문제가 발생합니다.
    - java에서는 다중 상속이 불가능
    - 공통 기능을 여러 클래스에 적용하려면 계층 구조가 복잡해짐
- 테스트 및 유지보수의 어려움
    - 부모 클래스의 내부 동작을 정확히 이해하지 않으면 예측하기 어려운 동작, 문제가 발생할 수도 있음
- 대안으로는 구성(Composition)
    - 다른 객체를 자신의 필드로 갖고, 그 객체의 기능을 사용하는 방식 (has-a 관계)
    - 필요 기능을 유연하게 주입
    - 상속보다 느슨한 결합 - > 변경에 유연함