# 실시간 채팅 구조
## Redis와 MongoDB를 함께 사용하면 실시간성, 영속성 두가지를 모두 충족할 수 있다.
[사용자 A] -> 메시지 전송 -> [Backend Server] -> Redis Pub/Sub -> [사용자 B]
이와 동시에 [Backend Server] -> MongoDB 저장(영구 저장)

### 1. 실시간 전송 : Redis Pub/Sub
- 사용자가 메세지를 보낸다면, 서버는 해당 메시지를 Redis의 특정 채널(ex:chatroom:100)에 publish한다.
- Redis는 이 채널을 subcribe 중인 다른 클라이언트들(예: 상대방, 채팅방 내 사용자 등)에게 바로 Push한다.
- 이 방식은 메시지를 중간 저장 없이 빠르게 브로드캐스트하는 데 적합하다.

### 2. 영속성 보장: MongoDB 저장
Redis Pub/Sub은 메시지를 저장하지 않는다.
-> 연결이 끊겼거나, 나중에 접속한 유저는 과거 메시지를 복구할 수 없다.
따라서 서버는 Redis에 메시지를 publish하는 동시에, MongoDB에 해당 메시지를 document로 저장한다.
```JSON
{ // 예를 들면 이런식
  "chatRoomId": "100",
  "senderId": "userA",
  "receiverId": "userB",
  "message": "안녕하세요!",
  "timestamp": "2025-05-05T15:00:00Z"
}
```

## 실무에서의 장점
- 속도와 영속성을 분리해서 처리하므로, 시스템이 복잡한 요구를 유연하게 대응할 수 있다.
- Redis는 메시지 브로커 역할에 집중하고, MongoDB는 검색과 히스토리 제공에 집중
- 클러스터링, 샤딩 구조에 적응하기도 쉬움


## 면접에서는 이렇게 물어볼 수 있음
### “Redis와 MongoDB를 함께 사용하는 구조의 장점은 무엇인가요?”
실시간성과 영속성을 분리하여 각각 최적화된 기술로 처리할 수 있다는 점에서 장점이 있다.
Redis는 인메모리 기반의 pub/sub 기능으로 지연 없이 메시지를 빠르게 전파할 수 있고,
MongoDB는 JSON 기반 문서 지향 NoSQL로, 채팅 메시지를 구조화된 형태로 저장하고 검색, 조회가 용이하다.

이를 통해 실시간 응답성과 사용자 재접속 시의 메시지 복원, 대화 기록 관리까지 각 기술의 강점을 조합한 아키텍처를 구성할 수 있습니다.
### “Redis Pub/Sub을 사용할 때 메시지 유실 문제는 어떻게 해결하나요?”
Redis Pub/Sub은 기본적으로 브로커 역할만 수행하고 메시지를 저장하지 않기 때문에, 구독자가 일시적으로 연결이 끊기면 메시지가 유실될 수 있다.
이 문제를 해결하기 위해 Server는 Pub/Sub으로 메시지를 publish하는 동시에, 해당 메시지를 MongoDB 같은 영속 저장소에 별도로 저장한다.
그리고 클라이언ㅌ가 재접속했을 때 MongoDB에서 과거 메시지를 조회하여 대화 내용을 복원한다.
###	“Kafka가 아니라 Redis를 사용하는 이유는 무엇인가요?”
Kafka는 강력한 내구성과 메시지 보관 기능, 대용량 로그 처리에 적합하지만, 설정과 운영이 복잡하고 메시지 지연이 Redis보다 높을 수 있다.
반면 Redis Pub/Sub은 설치와 사용이 간편하고, 메모리 기반으로 처리 속도가 매우 빠르기 때문에,
즉각적인 반응이 중요한 실시간 채팅에는 Redis가 더 적합한 선택.
또한 Redis는 이미 세션 관리, 캐싱 등 다른 기능과도 통합되어 있는 경우가 많기 때문에,
기존 인프라에 부담을 주지 않고 간단하게 채팅 기능을 구현할 수 있다는 점에서 실용적인 선택이 될 수 있다..