# 디자인 패턴
디자인 패턴은 소프트웨어 설계에서 반복적으로 발생하는 문젤르 해결하기 위한 '재사용 가능한 설계 템플릿'
-> like 족보
- 구체적인 코드가 아니라 구조적 해결 전략에 가깝다.
- 객체지향 설계 원칙(OOP, SOLID 등) 을 적용하는 실용적인 방법

## 왜 디자인 패턴을 사용하는가?
- 재사용성 : 검증된 설계 구조로 반복적인 문제를 효율적으로 해결
- 유지보수성 : 의도와 목적이 명확하므로 코드 이해가 쉽다
- 유연성/확장성 : 변경에 강한 구조로 개발이 가능하다
- 협업 효율성 : 개발자 간 공통 언어(용어) 제공 
    - ex ) "여기 싱클톤 씁니다."

## 디자인 패턴 분류(GoF)
| 유형 | 설명 | 예시 |
|--|--|--|
|생성(Creational)|객체 생성 방식을 유연하게 만듦|Singleton, Factory, Builder|
|구조(Structural)|클래스나 객체를 조합해 더 큰 구조를 만듦|Adapter, Decorator, Composite|
|행위(Behavioral)|객체 간 책임 분리의 상호작용 처리|Strategy, Observer, Template Method|

## 주요 디자인 패턴 간단 요약
| 패턴명 | 사용 목적 | 특징 | 패턴명 |
|--|--|--|---|
|Singleton|객체를 하나만 생성|전역 인스턴스 관리|Spring Bean|
|Factory Method|객체 생성 로직 캡슗화|조건에 따라 생성 객체 변경|Button Factory|
|Strategy|알고리즘 교체 가능|인터페이스 기반|결제, 정렬방식|
|Observer|상태 변경 감지 및 알림|이벤트 기반|알림 시스템, SSE|
|Decorator|기능을 동적으로 확장|상속 없이 조합|BufferedReader|
|Template Method|알고리즘 구조 정의|이부 단계만 자식 클래스에 위임|상속 기반 재사용|

## 함께 알면 좋은 연관 개념
### 1. SOLID 원칙
🔹 정의
SOLID는 객체지향 설계의 5가지 핵심 원칙으로, 유지보수성과 확장성을 높이기 위한 설계 지침입니다.

|약자| 명칭	|설명|관련 패턴 예시|
|-|-|-|-|
|S| 단일 책임 원칙|	클래스는 하나의 책임만 가져야 한다	|Single Responsibility 패턴, Strategy|
|O| 개방-폐쇄 원칙	|확장에는 열려 있고, 수정에는 닫혀 있어야 한다	|Decorator, Strategy|
|L| 리스코프 치환 원칙|	자식 클래스는 부모 클래스의 행위를 대체할 수 있어야 한다|	Template Method|
|I| 인터페이스 분리 원칙|	클라이언트는 자신이 사용하지 않는 인터페이스에 의존하면 안 된다|	Adapter|
|D| 의존 역전 원칙|	고수준 모듈은 저수준 모듈에 의존하지 말고, 추상에 의존해야 한다|	Factory Method, DI 컨테이너 활용|

### 2. 리팩토링 (Refactoring)
🔹 정의
기존의 기능을 변경하지 않으면서 코드의 구조를 개선하는 작업입니다.

🔹 중요성
- 가독성과 유지보수성 향상
- 중복 제거, 결합도 감소
- 테스트 용이성 증가

🔹 디자인 패턴과의 관계
복잡한 조건문, 중복 코드, 비효율적인 상속 구조 등을 리팩토링할 때 디자인 패턴을 도입해 구조를 개선할 수 있습니다.

예시:
- 긴 if-else → Strategy 패턴으로 대체
- 생성자 과다 → Builder 패턴 적용
- 중복된 기능 확장 → Decorator 패턴으로 구조화

### 3. 의존성 주입 (DI: Dependency Injection)
🔹 정의
객체가 사용할 의존 객체를 외부에서 주입받는 방식입니다. (직접 생성하지 않음)

🔹 장점
테스트 용이 (Mock 주입 가능)

클래스 간 결합도 감소 → 유연한 구조

객체 생성을 제어하는 책임을 분리

🔹 디자인 패턴과의 관계
DI를 활용하면 Strategy, Observer, State 패턴 등에서 필요한 전략 객체나 리스너 객체를 런타임에 주입할 수 있어 구조가 더욱 유연해집니다.

예시:
```java
paymentService.setStrategy(new KakaoPayStrategy());
```
- Spring에서는 @Autowired, @Inject, 생성자 주입 등을 통해 DI를 실현합니다.

### 4. 추상화 (Abstraction)
🔹 정의
복잡한 내부 구현을 감추고 필요한 인터페이스만 제공하는 구조 설계 원리

🔹 디자인 패턴과의 관계
- 거의 모든 디자인 패턴은 추상화를 기반으로 동작합니다.
- 인터페이스나 추상 클래스를 통해 동작의 틀만 제공하고, 실제 구현은 외부에서 결정

예시:
- Strategy: PaymentStrategy 인터페이스 정의 → 실제 구현은 외부에서 주입
- Factory Method: 생성 방식 자체를 추상화하여 확장성 확보
- Observer: 인터페이스를 통해 구독자/발행자의 결합을 느슨하게 유지

## 예상 질문
✅ Q1. 디자인 패턴이란 무엇인가요?

면접 답변 예시

디자인 패턴은 소프트웨어 설계 과정에서 자주 발생하는 문제에 대해 검증된 해결 구조를 의미합니다.
반복적인 문제 상황에서 일관되고 효율적인 방식으로 해결할 수 있도록 도와주며, 코드 재사용성과 유지보수성을 높이는 데 기여합니다.

✅ Q2. 실무에서 디자인 패턴을 적용한 경험이 있나요?

🔷 예시 1: Singleton 패턴

답변 예시

실무에서는 Singleton 패턴을 자주 사용했습니다.
예를 들어, 설정 값을 전역으로 관리하거나, 인증 토큰 검증 로직에서 공통 서비스 객체를 하나만 유지해야 할 경우에 사용했습니다.
Spring Framework에서는 기본적으로 Bean을 Singleton 스코프로 관리하기 때문에,
@Service, @Component로 등록한 클래스들은 Singleton처럼 동작하며, 의도한 대로 하나의 인스턴스를 재사용할 수 있었습니다.

이를 통해 매번 객체를 생성하지 않고도 효율적인 자원 관리와 상태 일관성을 유지할 수 있었습니다.

⸻

🔷 예시 2: Builder 패턴

답변 예시

DTO나 Entity 객체를 생성할 때 필드가 많거나 선택적 값이 존재하는 경우에는 Builder 패턴을 사용했습니다.
특히 사용자 등록 요청(Request DTO)에서 선택적인 필드가 많은 상황에서
생성자를 여러 개 오버로딩하거나, 무분별하게 setter를 사용하는 대신 UserDto.builder() 형태로 객체를 명확하게 구성할 수 있었습니다.

예를 들어, 필수값만 넣고 선택값은 유동적으로 조합할 수 있어 코드의 가독성과 안정성이 높아졌고,
생성자 파라미터 순서를 실수할 가능성도 줄어들어 유지보수에 유리했습니다.

⸻

✅ Q3. 자주 사용하는 디자인 패턴은 무엇이고, 어떤 상황에서 사용했나요?

예시 답변 (Singleton 패턴)

가장 자주 사용한 것은 Singleton 패턴입니다.
예를 들어, 설정값을 전역으로 관리하는 Config 객체나, 서비스 전체에서 동일한 Logger를 사용할 때 사용했습니다.
Bean 관리가 자동으로 Singleton으로 이루어지는 Spring 환경에서는 이를 더욱 자연스럽게 활용할 수 있었습니다.

⸻

✅ Q4. 디자인 패턴을 남용했을 때의 단점은 무엇인가요?

답변 예시

디자인 패턴은 구조적 문제 해결에는 좋지만, 불필요하게 적용하면 오히려 설계를 복잡하게 만들 수 있습니다.
예를 들어 간단한 로직에 추상화를 억지로 도입하면 오히려 유지보수가 어려워집니다.
따라서 패턴 적용 여부는 문제의 복잡도와 변경 가능성을 고려해서 결정하는 것이 중요하다고 생각합니다.

# ✅ 면접에 자주 나오는 디자인 패턴 정리
✅ 1. Singleton 패턴
- 개념: 객체를 오직 하나만 생성하여 어디서든 동일한 인스턴스를 공유
- 사용 목적: 전역 상태 관리, 리소스 절약
- 대표 예시: Spring의 Bean, Logger, DB 커넥션
- 면접 포인트
    - 멀티스레드 환경에서는 synchronized, double-checked locking 등 동기화 필요
    - 결합도가 높고 테스트 어려움 → DI로 대체 가능

✅ 2. Factory Method 패턴
- 개념: 객체 생성을 서브 클래스에 위임하여, 객체 생성 로직을 캡슐화
- 사용 목적: 클라이언트 코드에서 객체 생성 방식을 숨김
- 대표 예시: AnimalFactory.create("dog") → new Dog()
- 면접 포인트
    - OCP(개방-폐쇄 원칙) 준수
    - 의존성을 낮추고, 테스트가 쉬움

✅ 3. Iterator 패턴
- 개념: 컬렉션 내부 구조를 노출하지 않고 순차적으로 요소를 접근
- 사용 목적: 다양한 컬렉션을 일관된 방식으로 순회
- 대표 예시: Java의 Iterator, Python의 for-in
- 면접 포인트
    - 캡슐화 + 일관성 있는 순회 구조
    - 커스텀 컬렉션에서도 사용 가능

✅ 4. Strategy 패턴
- 개념: 알고리즘을 각각 클래스로 정의하고, 런타임에 교체 가능하게 구성
- 사용 목적: 조건문 제거, 유연한 행위 확장
- 대표 예시: 결제 전략 (KakaoPay, CardPay, NaverPay)
- 면접 포인트
    - if-else 제거
    - DI와 함께 사용 → 유연한 구조 설계
    - OCP 만족

✅ 5. Observer 패턴
- 개념: 상태 변화가 발생하면 등록된 여러 객체에 자동 알림
- 사용 목적: 이벤트 기반 구조, 실시간 처리
- 대표 예시: UI 이벤트 리스너, SNS 알림, 채팅방 알림
- 면접 포인트
    - 느슨한 결합, 다대다 관계
    - 성능 저하나 순서 예측 어려움 존재

✅ 6. Proxy 패턴
- 개념: 실제 객체 대신 대리 객체를 통해 접근 제어
- 사용 목적: 접근 제어, 로깅, 지연 로딩, 캐싱 등
- 대표 예시: Spring AOP, 가상 프록시, 보안 프록시
- 면접 포인트
    - 실제 객체와 동일한 인터페이스를 제공
    - 기능 추가, 보호, 모니터링에 유용

✅ 7. MVC / MVP / MVVM 패턴
|패턴|	구성 요소|	특징|	대표 예시|
|-|-|-|-|
|MVC|Model - View - Controller|	Controller가 입력을 처리하고 View와 Model을 연결|Spring MVC, Django|
|MVP|Model - View - Presenter|	Presenter가 View에 의존 없이 모든 로직 수행|Android (Java 시절)|
|MVVM|Model - View - ViewModel|	ViewModel과 View가 데이터 바인딩으로 연결|Android(Kotlin), Vue, SwiftUI|

- 공통 목표: 관심사 분리 (Separation of Concerns)
- 면접 포인트
    - MVC: 입력 중심, 구조화 쉬움
    - MVP: 테스트 용이, View가 더 얇음
    - MVVM: 양방향 바인딩, 상태 관리 용이

