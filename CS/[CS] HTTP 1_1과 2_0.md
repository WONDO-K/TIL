# HTTP 1.1 vs 2.0
## HTTP / 1.1
HTTP는 웹상에서 클라이언트와 서버 간 통신을 위한 프로토콜이다.  
HTTP/1.1의 경우에는 매 요청마다 새로운 TCP 커넥션을 생성하는 방식으로 인한 오버헤드가 존재했다. 하지만 Persistent Connection(Keep-Alive) 덕분에 한 번 생성한 커넥션을 일정 시간 동안 유지하여 다수의 요청을 한 연결에서 처리할 수 있게 되었으며, 이를 통해 연결 생성에 따른 비용을 줄였다. 그럼에도 불구하고 Head-of-Line(HOL) Blocking 문제가 여전히 존재한다는 점이 큰 한계로 남았다.

또한, 파이프라이닝(HTTP Pipelining)을 지원하여 요청의 응답 지연을 감소하고자 했으나, 실제로는 대부분의 브라우저에서 제대로 지원되지 않아 널리 활용되지 못했다. 파이프라이닝에서는 HTTP 요청이 연속적이며 순차적으로 전달된다. 기존에는 요청한 이후에 응답을 기다리고 그 다음 요청을 보냈다. 파이프라이닝에서는 필요한 모든 자원에 대한 요청을 순차적으로 서버로 전송한 다음 모든 요청에 대한 응답을 한 번에 기다리게 된다. 하지만 이 방식도 첫 번째 요청이 지연되면 뒤따르는 요청들이 모두 영향을 받는 HOL Blocking 문제를 완전히 해결하지 못했다.

HTTP/1.1은 1.0 버전에 비해 상당히 개선됐지만 여전히 문제가 존재한다. 대표적으로 Head-of-Line Blocking 문제가 있다. 이는 파이프라이닝에서 발생하는 문제로, 만약 3개의 요청을 파이프라인을 통해 전송한다고 했을 때, 서버는 모든 요청을 순서에 맞춰서 응답해야 한다. 이때 첫 번째 요청이 오래 걸린다고 하면, 나머지 요청은 첫 번째 요청의 처리를 기다려야 한다. 또한, HTTP/1.1은 요청과 응답의 헤더 크기가 커질수록 성능이 저하되는 문제가 있다. 이는 동일한 헤더가 매 요청마다 전송되기 때문이다.

## HTTP / 2.0
HTTP/2.0은 이러한 문제를 해결하기 위해 개발된 프로토콜이다. HTTP/1.1은 메시지를 일반 텍스트 형태로 전송했지만, HTTP/2.0부터는 기본 HTTP 메시지를 프레임이라는 단위로 분할하고 이를 바이너리 형태로 전송한다. 이로 인해 파싱 및 전송 속도가 크게 개선되었다.

HTTP/2.0은 바이너리 프로토콜로, 헤더 압축(HPACK) 및 멀티플렉싱을 지원한다. 이를 통해 여러 요청과 응답을 동시에 처리할 수 있으며, 헤더 크기를 줄여 성능을 개선한다. 또한, 스트림 우선순위(Flow Control) 기능을 도입하여 중요한 요청을 우선 처리할 수 있게 하여 리소스 분할의 효율성을 높였다.

HTTP/2.0의 멀티플렉싱 기능은 여러 요청을 하나의 TCP 연결에서 동시에 처리할 수 있게 해준다. 이를 통해 HTTP/1.1에서 발생하던 HOL Blocking 문제를 애플리케이션 레벨에서 완화했지만, TCP 기반이기 때문에 패킷 손실 시 TCP 레벨에서의 HOL Blocking은 여전히 존재한다. 이러한 TCP 레벨 HOL Blocking 문제는 HTTP/3의 등장 배경이 되었다.

또한, HTTP/2.0은 보안을 강화하기 위해 TLS와 ALPN(Application-Layer Protocol Negotiation)을 기본적으로 지원하여 안전한 통신을 보장한다. 그리고 서버 푸시(Server Push) 기능을 도입하여 클라이언트가 요청하지 않은 리소스도 미리 전송할 수 있어 페이지 로딩 속도를 개선할 수 있다.

## HTTP / 3.0
HTTP/3는 QUIC 프로토콜을 기반으로 한 최신 버전이다. QUIC은 UDP 위에서 동작하며, TCP와 달리 패킷 손실 시에도 연결 전체가 지연되는 HOL Blocking 문제를 해결한다. 또한, QUIC은 빠른 연결 복구와 0-RTT 재개 기능을 제공하여 지연 시간을 더욱 줄인다. HTTP/3는 이러한 QUIC의 장점을 활용하여 더욱 빠르고 안정적인 웹 통신을 가능하게 한다.