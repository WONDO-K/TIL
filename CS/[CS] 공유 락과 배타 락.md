# 공유 락과 배타 락
DBMS에서 트랜잭션을 별도의 제어 없이 병행 수행하도록 허용하면 데이터의 일관성과 무결성을 보장하기 어려울 수 있다.
이때 병행 수행되는 트랜잭션들을 제어하기 위해 락을 사용할 수 있으며, DBMS에서 락은 크게 공유 락과 배타 락으로 분류된다.

## 공유 락(Shared Lock)
공유 락은 읽기 락(Read Lock)이라고도 부르며, 공유 락이 걸린 데이터에 대해서 다른 트랜잭션들도 공유 락은 획득할 수 있지만, 배타 락은 획득할 수 없다. 즉, 공유 락을 사용하면 트랜잭션 내에서 조회하는 데이터가 변경되지 않는다는 것을 보장한다.
공유 락은 데이터의 읽기 일관성을 보장하며, 동시에 여러 트랜잭션이 읽기 작업을 수행할 수 있도록 한다.
```sql
SELECT * FROM table_name WHERE id = 1 FOR SHARE;
```

## 배타 락(Exclusive Lock)
배타 락은 쓰기 락(Write Lock) 또는 Exclusive Lock이라고도 한다. 배타 락이 걸린 데이터에 대해서는 다른 트랜잭션에서 공유 락과 배타 락 모두를 획득할 수 없다. 즉, 배타 락을 획득한 트랜잭션은 데이터에 대한 읽기와 쓰기 모두의 독점권을 가진다.
```sql
SELECT * FROM table_name WHERE id = 1 FOR UPDATE;  -- 주로 수정, 삭제가 예상될 때 사용
```

정리하자면, 공유 락이 걸린 데이터는 다른 트랜잭션에서 공유 락을 획득할 수 있지만, 배타 락이 걸린 데이터는 다른 트랜잭션에서 어떤 종류의 락도 획득할 수 없어 잠금 대기(lock wait)가 발생하여 성능 저하나 교착 상태로 이어질 수 있다.

## 데드락
데드락(Deadlock)이란 교착 상태로, 두 개 이상의 트랜잭션이 서로 필요로 하는 데이터의 락을 점유하고 있어서 서로의 락 해제를 기다리며 무한히 대기하는 상황을 말한다.
트랜잭션이 락을 획득하지 못하면, 다른 트랜잭션이 점유하고 있는 락이 해제될 때까지 대기한다.
예를 들어, 다음과 같은 트랜잭션들이 있다고 가정해보자.
- 트랜잭션 A와 B가 있고, id가 1, 2인 데이터가 있다.
- 트랜잭션 A는 id=1 데이터를 읽고, id=2 데이터를 변경하려고 한다.
- 트랜잭션 B는 id=2 데이터를 읽고, id=1 데이터를 변경하려고 한다.

이때 아래와 같은 순서로 데드락이 발생할 수 있다.
1. 트랜잭션 A가 id=1 데이터에 공유 락을 획득한다.
2. 트랜잭션 B가 id=2 데이터에 공유 락을 획득한다.
3. 트랜잭션 A가 id=2 데이터에 배타 락을 요청하지만, 이미 B가 공유 락을 점유하고 있어 대기한다.
4. 트랜잭션 B가 id=1 데이터에 배타 락을 요청하지만, 이미 A가 공유 락을 점유하고 있어 대기한다.
5. 결과적으로 A와 B 모두 서로의 락 해제를 기다리며 무한 대기(데드락)에 빠진다.

> 데드락을 해결하기 위해서는 트랜잭션에서 락 획득 순서를 일관되게 지정할 수 있다.
> 예를 들어, 모든 트랜잭션이 항상 id=1, id=2 순서로 락을 획득하면 데드락이 발생하지 않는다.
> 또는 락 타임아웃을 설정하여 일정 시간 동안 락을 획득하지 못하면 트랜잭션을 강제로 종료할 수 있다.
> 트랜잭션의 격리 수준(예: SERIALIZABLE)을 높이는 것도 일부 상황에서 도움이 될 수 있다.

## ✅ 데드락(Deadlock) 해결 방법 — 상세 설명

### 1. 락 획득 순서를 통일
- 💡 왜 필요한가요?
  - 데드락은 서로 다른 트랜잭션이 서로 다른 순서로 락을 요청할 때 발생한다.
  - 락 요청 순서가 일관되지 않으면 두 트랜잭션이 서로 상대방의 락 해제를 기다리며 무한 대기에 빠질 수 있다.
- 🛠 어떻게 해결하나요?
  - 항상 동일한 순서로 데이터를 조회하고 락을 거는 규칙을 만든다.
  - 예시:
    ```sql
    SELECT * FROM orders WHERE id = 1 FOR UPDATE;
    SELECT * FROM orders WHERE id = 2 FOR UPDATE;
    ```
  - 모든 트랜잭션이 한 방향으로만 진행하게 되어 데드락이 방지된다.

### 2. 락 타임아웃 설정
- 💡 왜 필요한가요?
  - 데드락은 무한 대기 상태이기 때문에 타임아웃 없이 기다리면 시스템이 멈추거나 서비스가 느려질 수 있다.
- 🛠 어떻게 해결하나요?
  - 락을 일정 시간 이상 획득하지 못하면 자동으로 트랜잭션 실패 또는 롤백 처리한다.
  - MySQL 예시:
    ```sql
    SET innodb_lock_wait_timeout = 5;
    ```
  - Java 코드 예시:
    ```java
    @Transactional(timeout = 5)
    public void processOrder() { ... }
    ```
  - 타임아웃 설정은 장애 예방에 매우 효과적이다.

### 3. 트랜잭션 격리 수준 조정
- 💡 왜 필요한가요?
  - 낮은 격리 수준에서는 데이터 읽기-쓰기 충돌이 자주 발생하여 데드락 가능성이 높아진다.
- 🛠 어떻게 해결하나요?
  - 격리 수준을 높이면 충돌 가능성을 줄이고 데이터 일관성과 무결성을 보장할 수 있다.
  - 예시:
    ```sql
    SET TRANSACTION ISOLATION LEVEL SERIALIZABLE;
    ```
  - 격리 수준 표:

    | 격리 수준         | 설명                                       |
    |------------------|--------------------------------------------|
    | READ COMMITTED    | 커밋된 데이터만 읽음, 데드락 가능성 존재     |
    | REPEATABLE READ   | 같은 트랜잭션 내에서는 항상 동일한 데이터   |
    | SERIALIZABLE      | 가장 엄격, 완전한 직렬화, 데드락 거의 없음 |

## 💡 실무 팁
| 해결책          | 사용 상황                                       |
|---------------|-----------------------------------------------|
| 락 순서 통일   | 동일 테이블 여러 행을 동시에 업데이트하는 경우 |
| 락 타임아웃    | 요청이 많고 지연이 허용되지 않는 서비스         |
| 격리 수준 조정 | 은행, 결제 등 일관성이 중요한 시스템           |

## 💡 추가로 알아두면 좋은 개념

- **낙관적 락 vs. 비관적 락**
  - 비관적 락(Pessimistic Lock): 충돌 가능성이 높을 때 미리 락으로 보호
  - 낙관적 락(Optimistic Lock): 충돌 가능성이 낮아 락 없이 처리, 충돌 시 롤백

| 구분       | 설명                                 | 사용 예시               |
|----------|------------------------------------|----------------------|
| 비관적 락 | 충돌 날 것 같으면 미리 락 건다            | 결제, 재고, 계좌 이체 등 |
| 낙관적 락 | 일단 락 안 걸고 → 마지막에 변경 여부 확인 | 읽기 위주 시스템, 게시판 등 |

- **트랜잭션 격리 수준과의 관계**
  - 락은 트랜잭션의 일관성 유지를 위한 도구로, 격리 수준(READ COMMITTED, REPEATABLE READ 등)과 밀접한 관련이 있다.

- **락 타임아웃 설정**
  - 락을 일정 시간 이상 획득하지 못하면 실패하도록 설정하여 데드락을 방지할 수 있다. (예: `lock_timeout` 설정)