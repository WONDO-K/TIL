# 서버 사이드 랜더링과 클라이언트 사이드 랜더링의 차이점
## 서버 사이드 랜더링 (SSR)
- 서버 측에서 랜더링 하는 방식
- 클라이언트가 서버에 요청을 보내면, 서버는 페이지에 필요한 데이터를 가져와 CSS까지 적용하여 랜더링 준비를 마친 후 HTML, JSON 코드를 리턴한다.
- 브라우저에서는 JS 코드를 다운로드 하고, HTML에 JS 코드를 삽입하여 페이지를 랜더링한다.
- 이처럼 모든 데이터가 이미 HTML에 담긴 채로 전달되기 때문에 SEO에 유리하다.
- 또한 JS 코드를 다운로드 받고 실행하기 전에 사용자가 이미 랜더링된 페이지를 볼 수 있기 때문에, JS 다운로드를 기다려야 하는 CSR에 비해 초기 로딩 속도가 빠르다.

## 클라이언트 사이드 랜더링 (CSR)
- 클라이언트 측에서 랜더링 하는 방식
- 클라이언트가 서버에 컨턴츠를 요청하면, 서버는 빈 HTML 파일을 리턴한다.
- 클라이언트는 연결된 JS 링크를 통해 서버로부터 다시 JS 파일을 다운로드 받은 뒤, JS를 통해 동적으로 페이지를 만들어 브라우저에 랜더링한다.
- 빈 뼈대만 있는 HTML 파일이 클라이언트로 전송되기 때문에, 웹 크롤러 봇 입장에서는 색인할만한 컨텐츠가 존재하지 않아 SEO에 불리하다.
- 또한 브라우저가 JS 파일을 다운로드 하고, 동적으로 DOM을 생성하는 과정이 필요하기 때문에, 초기 로딩 속도가 느리다는 단점이 있다.
- 하지만 CSR은 초기 로딩 이후 페이지 일부를 변경할 때에는 서버에 해당 데이터만 요청하면 되기 때문에 이후의 구동 속도가 빠르다.
- 서버는 HTML 뼈대를 넘겨주는 역할만 수행하면 되므로 서버의 부하가 적고, 클라이언트 측에서 연산과 라우팅 등을 직접 처리하기 때문에 반응속도가 빠르고 사용자 경험이 향상된다.

## SEO란?
- SEO(검색 엔진 최적화)는 웹사이트가 검색 엔진 결과 페이지(SERP)에서 더 높은 순위를 차지하도록 최적화하는 과정이다.
- 이는 웹사이트의 가시성을 높이고, 유기적 트래픽을 증가시키는 데 중요한 역할을 한다.
- SEO는 키워드 최적화, 메타 태그 작성, 사이트 구조 개선, 백링크 구축 등 다양한 요소를 포함한다.
- 검색 엔진은 웹사이트의 콘텐츠를 크롤링하고 색인화하여 사용자에게 가장 관련성 높은 결과를 제공한다.
- 따라서 웹사이트가 검색 엔진에 최적화되어 있으면, 사용자가 검색할 때 더 쉽게 발견될 수 있다.
### 랜더링 전략이 SEO에 미치는 영향
- 서버 사이드 랜더링(SSR)은 초기 페이지 로딩 시 모든 콘텐츠가 이미 HTML에 포함되어 있기 때문에, 검색 엔진 크롤러가 페이지를 쉽게 색인화할 수 있다. 이는 검색 엔진 최적화(SEO)에 유리하다.
- 반면 클라이언트 사이드 랜더링(CSR)은 초기 로딩 시 빈 HTML 파일이 전달되므로, 검색 엔진 크롤러가 페이지의 콘텐츠를 제대로 색인화하지 못할 수 있다. 이는 SEO에 불리한 영향을 미칠 수 있다.
- 따라서 웹사이트의 SEO를 고려할 때, 서버 사이드 랜더링(SSR)을 사용하는 것이 더 효과적일 수 있다. 
### 초기 로딩은 SSR로, 이후에 전환은 CSR로 한다면?
- 초기 로딩 시 서버 사이드 랜더링(SSR)을 사용하여 모든 콘텐츠를 포함한 HTML을 전달하고, 이후 페이지 전환이나 동적 콘텐츠 업데이트는 클라이언트 사이드 랜더링(CSR)을 통해 처리하는 전략을 사용할 수 있다.
- 이 접근 방식은 초기 로딩 속도를 빠르게 유지하면서도, 이후 사용자 상호에 따라 동적으로 콘텐츠를 업데이트할 수 있는 유연성을 제공한다.
- SEO 측면에서도 초기 로딩 시 모든 콘텐츠가 포함되어 있기 때문에 검색 엔진 크롤러가 페이지를 쉽게 색인화할 수 있다.

---

## Java Spring 기반 SSR + CSR 혼합 전략의 한계

Spring 환경에서도 SSR(서버 사이드 렌더링)과 CSR(클라이언트 사이드 렌더링)을 혼합하는 전략은 구현 가능하지만, 다음과 같은 이유로 실무에서 비효율적일 수 있다:

### SSR + CSR 혼합 전략의 단점 (Java Spring 기준)

| 항목 | 문제점 |
|------|--------|
|  템플릿 한계 | SSR을 위한 Thymeleaf/JSP와 CSR을 위한 React/Vue를 동시에 관리하면 빌드 체인과 코드 관리가 복잡해진다. |
|  라우팅 충돌 | Spring의 서버 라우팅과 CSR 프레임워크의 클라이언트 라우팅(예: React Router) 간 충돌 가능성 존재 |
|  초기 로딩 이중화 | SSR HTML에 포함된 데이터를 CSR JS에서 다시 파싱하거나 API를 중복 호출하는 번거로움 |
|  전체 페이지 갱신 문제 | Spring MVC의 SSR은 보통 전체 페이지를 다시 렌더링하므로 CSR처럼 부드러운 페이지 전환이 어려움 |
|  코드 유지보수 | 템플릿 로직과 JS 로직이 분산되어 개발 및 유지보수가 어렵고 테스트도 복잡함 |

### 대안

- Java Spring은 백엔드 API 서버로 구성하고, 프론트엔드는 Next.js(React 기반) 등으로 SSR+CSR 처리를 맡기는 구조가 일반적이다.
- 예: 초기 페이지는 Next.js SSR로 처리하고, 이후 전환은 CSR로 처리. 백엔드는 Spring이 JSON API만 제공