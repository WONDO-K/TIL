# OSIV(Open Session In View) 옵션
OSIV는 영속성 컨텍스트를 뷰까지 열어둔다는 의미이다. 영속성 컨텍스트가 살아있으면 엔티티는 영속 상태로 유지될 수 있어, 뷰에서도 지연 로딩을 사용할 수 있다. OSIV의 핵심은 뷰에서도 지연 로딩이 가능하도록 하는 것이다.
가장 단순한 구현은 클라이언트 요청이 들어올 때 필터나 언터셉터에서 트랜잭션을 시작하는 방법이다.
이를 트랜잭션 방식 OSIV라고 한다. 하지만, 트랜잭션 방식 OSIV는 표현 계층에서도 엔티티를 수정할 수 있기 때문에 유지보수가 어려운 코드를 만들 수 있다.

## 트랜잭션 방식의 OSIV의 문제는 어떻게 풀 수 있는가?
최신 방식의 OSIV는 트랜잭션 방식의 문제를 해결한다.
스프링 OSIV는 OSIV를 사용하면서 트랜잭션은 비즈니스 계층에서만 사용한다.
표현 계층에서는 트랜잭션이 없기 때문에 수정이 불가능하다. 하지만, 표현 계층에서 트랜잭션 없는 읽기를 이용해 지연 로딩은 가능하다.
### 동작 원리
- 클라이언트의 요청이 들어오면 서블릿 필터나 스프링 인터셉터에서 영속성 컨텍스트를 생성한다.
- 응용 계층에서 @Transactional로 트랜잭션을 시작할 때 미리 생성한 영속성 컨텍스트를 찾아와서 트랜잭션을 시작한다.
- 응용 계층이 끝나면 트랜잭션을 커밋하고 영속성 컨텍스트를 플러시한다.(영속성 컨텍스트는 종료하지 않는다.)
- 컨트롤러와 뷰까지 영속성 컨텍스트가 유지되므로 조회한 엔티티는 영속 상태를 유지할 수 있다.
- 필터, 인터셉터로 요청이 돌아오면 영속성 컨텍스트를 종료하는 데 이때 플러시는 수행하지 않는다.

## 스프링 방식의 OSIV의 문제점
- 표현 계층에서 엔티티를 수정하면 데이터베이스에 반영하지 않는다. 하지만, 엔티티를 수정한 이후 트랜잭션을 시작하는 응용 계층을 시작한 경우 문제가 발생한다. 응용 계층 트랜잭션이 끝나고 영속성 컨텍스트를 플러시 하는 과정에서 변경 감지가 동작할 수 있다.
- OSIV 기능을 사용하면 상대적으로 오래 DB 커넥션을 점유하기 떄문에 커넥션 고갈로 이어질 수 있다.

## OSIV 기능 비활성화로 성능 최적화를 시도할 수 있다.
- OSIV 기능이 활성화되어 있는 경우에는 트랜잭션의 범위를 벗어나도 커넥션을 계속 유지한다.
- 만약 트래픽을 많이 받는 상황이라면, 커넥션 고갈로 이어질 수 있따.
- OSIV 기능을 비활성화여 데이터베이스 커넥션을 효율적으로 사용할 수 있다.

## 무조건 비활성화해야 하는가?
- 무조건 비활을 하기보다는 비활성화의 근거가 필요하다. 만약 트랜잭션 범위 밖에서 지연 로딩을 반드시 수행해야하는 경우에는 비활성화하기 어려울 수 있다.
- 데이터베이스를 복제하여 사용하는 경우, 데이터 소스도 분리해야하는데 OSIV 기능으로 인해 예기치 않은 데이터베이스로 요청이 전달될 수 있다. 그리고, 대량의 트래픽이 발생하는 경우처럼 데이터베이스 커넥션을 효율적으로 사용해야할 수도 있다. 이 경우에는 OSIV의 비활성화를 고려해봄직하다.

---

## 🧠 OSIV(Open Session In View) 쉽게 요약

### OSIV란?
- JPA의 **지연 로딩(Lazy Loading)**을 Controller나 View(템플릿) 계층까지 가능하게 하기 위해 DB 세션을 끝까지 열어두는 전략
- 즉, **트랜잭션은 끝났지만 영속성 컨텍스트(DB 연결)는 계속 유지**

### 왜 등장했나?
- 서비스 계층에서 Lazy 로딩용 연관 엔티티를 불러오지 않고 View에서 접근하려고 하면 예외 발생
- `LazyInitializationException` 방지 목적

---

## ✅ 작동 방식
- 요청 시작 시 영속성 컨텍스트 생성
- 서비스 계층에서 트랜잭션 시작 → 끝나도 DB 세션은 유지
- Controller나 View에서 지연 로딩 호출 가능
- 응답 반환 직전에 영속성 컨텍스트 종료

---

## ✅ 장점
- View에서도 Lazy 로딩이 자연스럽게 작동
- 빠르게 개발 가능 (초기 개발 속도에 유리)

---

## ❗ 단점 (실무상 문제)
- **DB 커넥션을 오래 점유**해서 트래픽 많을 때 커넥션 고갈 위험
- View나 Controller에서 엔티티 수정 시, 트랜잭션이 없어도 변경 감지(flush)로 인해 의도치 않은 DB 반영 가능
- **표현 계층에서 도메인 로직이 뒤섞여 유지보수 어려움**

---

## 🧩 끄는 게 정답인가?
> 무조건 OFF는 아님. 상황에 따라 판단해야 함.

### OSIV 끄는 경우 (추천 상황)
- 트래픽이 많은 서비스
- View에서 Lazy Loading 불필요
- 서비스 계층에서 DTO로 가공해서 넘김
- DB 커넥션 효율적 사용 필요

```yaml
# application.yml
spring:
  jpa:
    open-in-view: false
```

### OSIV 유지하는 경우
- View에서 Lazy Loading이 꼭 필요한 경우
- 개발 초기 단계에서 빠르게 개발할 때

---

## 🎯 정리

| 항목 | 설명 |
|------|------|
| 목적 | View에서 Lazy Loading 가능하게 하기 위해 |
| 기본 동작 | DB 세션을 Controller/Template까지 유지 |
| 단점 | 커넥션 장시간 점유, 표현 계층에서의 도메인 수정 위험 |
| 실무 팁 | DTO로 변환해 Controller에 전달 → OSIV 없이도 안정적 처리 가능 |
